# HJ4字符串分隔

判断字符长度，分是否为0，大于8，小于8，通过列表的切片，前者进行输出和后者赋值进入下个循环

# 进制转换

设进制为x
通过n % x 取模的方法，依次获取低位到高位的数字

$0 <= a_i < x,a_i为整数 $

$(n)_{10} = a_0x^0 + a_1x^1 + ......+ a_ix^i +......+a_{n-1}x^{n-1} $

# 质因数分解

任何合数 n 的最小质因子一定 ≤ √n。
因此，我们只需枚举从 2 到 √n 的可能因子。
注意的点：
1.只有一个质因子的情况
2.枚举时应将每个数除以迭代后的数(n = n//i)直至除不尽为止，得到x个相同的因子。

# 排序注意点

1 **请转换为int类型后再排序**

同样是数字，用字符串类型排序和用int类型排序最后的结果会不一致。

2 字典排序写法

sorted(dict1) 返回的是排序号的key值列表，不能使用.items()
可用下面方法排序：
`sorted_items = sorted(d.items(), key=lambda x: (-x[1], x[0]))`

这行代码的作用是：对字典 d 的键值对按“值降序、键升序”进行排序。

# 列表错误操作

1 反转操作

list1 = list(var1).reverse
错误点：
list.reverse()，reverse()是list类里面的方法，需要完整写，且返回none，导致list1 = none
所以列表转换和列表翻转应该分开进行操作

```python
list1 = list(var1)
list2 = list1.reverse
```

2 错误初始化

```python
# list1 = [] * n ,实际上这只会创建一个空列表
list1 = [] * 4                  >>> []
# 正确操作
list2 = [[] for _ in range(4)]  >>> [[], [], [], []]
list2 = [[None]] * 4            >>> [[None], [None], [None], [None]]

list2 = [None] * 4              >>> [None, None, None, None]
```

# 字符格式化操作

1 format语法-引索方式

```python
# 错误写法 {}内如果不是引索值，format()内的写法必须是 {}内变量名 = 值或者变量
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x, max_n), row)) 

# 正确写法 {}内的是参数名，format()内的是传入参数，应通过引索或者赋值的方式指示如何传入参数
formatted_row = list(map(lambda x: "{0:<{1}s}".format(x, max_n), row))
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x=x, max_n=max_n), row))

print('{:#08x}'.format('16')) # 错误，数字格式化，不能用字符串类型
print('{:#08s}'.format('16'))
print('{:#08x}'.format(16)) 
```

# python3 除运算新特性

| 表达式      | 结果    | 类型      | 说明                 |
| -------- | ----- | ------- | ------------------ |
| `7 / 2`  | `3.5` | `float` | 真除法（true division） |
| `7 // 2` | `3`   | `int`   | 整除（floor division） |
| `8 / 2`  | `4.0` | `float` | 即使整除也是 float       |
| `8 // 2` | `4`   | `int`   | ✅ 真正的整数            |

# 字符串操作

split()方法注意点：
'.'split(".") >>> ['', '']
是会返回空元素的，需要考虑空元素的存在

# HJ18 识别有效的IP地址和掩码并进行分类统计

注意审题
"0.*.*.*" 和 "127.*.*.*" 的 IP 地址不计入任何类别，也不计入非法统计
正确逻辑
IP是否合法
不合法 
合法：
0,127判断>不操作
错误mask判断
再进行分类

# 子字符串重复验证

思路：假设验证是否存在m长度以上的子串重复，只需要判断字符串中(m+1)长度是否存在重复即可(即存在重复的长度n的子串，则必存在重复的n-1的子串)
暴力：切片，与后面的比较
辅助字典查看是否重复或列表 查看去重后长度是否一致

# for循环注意点

1 计数变量写的位置要考虑

```pyhton
r = 0
for i in range(n):

for i in range(n):
    r = 0
```

2 通过判断数组内元素来进行操作时，要留意末尾情况

```python
# 下面操作是将非字母字符作为间隔，获取单词。
# 还要考虑到最后一个单词后面是没有非字母字符，导致他没有加入到rec
rec = ''
for i in s:
    if i.isalpha():
        rec += i
    else:
        words.append(rec)
        rec = ''
words.append(rec)

# 当然该题可以通过.replace()，替换为空格，这样不容易出错
```

3 分段获取模板

```python
b = '00001010000000000000001111000001'
for i in range(0,32,8):
        n = int(b[i:i+8],2)
# 注意range的三个参数 和切片的步长
```

4 循环里面不要修改(当前正在遍历的对象)的操作
```pyhton
# 遍历list1，但循环里面却对list1进行了操作
for i in list1:
    list1.append(i)

# 正确做法是复制一份
list2 = list1 
for i in list2:
    list1.append(i)
# 注意不要用可迭代方式进行复制
# .item返回的是可迭代对象的视图，其实是一个指针，对dic2操作同样会修改dic1的
dic2 = dic1.item()
for i ,j in dic2:
    ...

```
