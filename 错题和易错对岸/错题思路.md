# HJ4字符串分隔

判断字符长度，分是否为0，大于8，小于8，通过列表的切片，前者进行输出和后者赋值进入下个循环

# 进制转换

设进制为x
通过n % x 取模的方法，依次获取低位到高位的数字

$0 <= a_i < x,a_i为整数 $

$(n)_{10} = a_0x^0 + a_1x^1 + ......+ a_ix^i +......+a_{n-1}x^{n-1} $

# 质因数分解

任何合数 n 的最小质因子一定 ≤ √n。
因此，我们只需枚举从 2 到 √n 的可能因子。
注意的点：
1.只有一个质因子的情况
2.枚举时应将每个数除以迭代后的数(n = n//i)直至除不尽为止，得到x个相同的因子。



# 列表错误操作

1 反转操作

list1 = list(var1).reverse
错误点：
list.reverse()，reverse()是list类里面的方法，需要完整写，且返回none，导致list1 = none
所以列表转换和列表翻转应该分开进行操作

```python
list1 = list(var1)
list2 = list1.reverse
```

2 错误初始化

```python
# list1 = [] * n ,实际上这只会创建一个空列表
list1 = [] * 4                  >>> []
# 正确操作
list2 = [[] for _ in range(4)]  >>> [[], [], [], []]
list2 = [[None]] * 4            >>> [[None], [None], [None], [None]]

list2 = [None] * 4              >>> [None, None, None, None]
```

# 字符格式化操作

1 format语法-引索方式

```python
# 错误写法 {}内如果不是引索值，format()内的写法必须是 {}内变量名 = 值或者变量
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x, max_n), row))

# 正确写法 {}内的是参数名，format()内的是传入参数，应通过引索或者赋值的方式指示如何传入参数
formatted_row = list(map(lambda x: "{0:<{1}s}".format(x, max_n), row))
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x=x, max_n=max_n), row))

print('{:#08x}'.format('16')) # 错误，数字格式化，不能用字符串类型
print('{:#08s}'.format('16'))
print('{:#08x}'.format(16))
```

# python3 除运算新特性

| 表达式      | 结果    | 类型      | 说明                 |
| -------- | ----- | ------- | ------------------ |
| `7 / 2`  | `3.5` | `float` | 真除法（true division） |
| `7 // 2` | `3`   | `int`   | 整除（floor division） |
| `8 / 2`  | `4.0` | `float` | 即使整除也是 float       |
| `8 // 2` | `4`   | `int`   | ✅ 真正的整数            |

# 字符串操作

split()方法注意点：
'.'split(".") >>> ['', '']
是会返回空元素的，需要考虑空元素的存在

# HJ18 识别有效的IP地址和掩码并进行分类统计

注意审题
"0.*.*.*" 和 "127.*.*.*" 的 IP 地址不计入任何类别，也不计入非法统计
正确逻辑
IP是否合法
不合法
合法：
0,127判断>不操作
错误mask判断
再进行分类

# 子字符串重复验证

思路：假设验证是否存在m长度以上的子串重复，只需要判断字符串中(m+1)长度是否存在重复即可(即存在重复的长度n的子串，则必存在重复的n-1的子串)
暴力：切片，与后面的比较
辅助字典查看是否重复或列表 查看去重后长度是否一致

# for循环注意点

1 计数变量写的位置要考虑

```pyhton
r = 0
for i in range(n):

for i in range(n):
    r = 0
```

2 通过判断数组内元素来进行操作时，要留意末尾情况
写完循环后，最后一次遍历十分容易忽略，**检查是否有对循环后的状态有进行判定**
```python
# 下面操作是将非字母字符作为间隔，获取单词。
# 还要考虑到最后一个单词后面是没有非字母字符，导致他没有加入到rec
rec = ''
for i in s:
    if i.isalpha():
        rec += i
    else:
        words.append(rec)
        rec = ''
words.append(rec)

# 当然该题可以通过.replace()，替换为空格，这样不容易出错
```

3 分段获取模板

```python
b = '00001010000000000000001111000001'
for i in range(0,32,8):
        n = int(b[i:i+8],2)  # 8个字符一段，转为二进制
# 注意range的三个参数 和切片的步长
```

4 循环里面不要修改(当前正在遍历的对象)的操作
```pyhton
# 遍历list1，但循环里面却对list1进行了操作
for i in list1:
    list1.append(i)

# 正确做法是复制一份
list2 = list1
for i in list2:
    list1.append(i)
# 注意不要用可迭代方式进行复制
# .item返回的是可迭代对象的视图，其实是一个指针，对dic2操作同样会修改dic1的
dic2 = dic1.item()
for i ,j in dic2:
    ...

```
5 循环中的低效统计频次方法
```python
# 错误方法,以下方法计算频次十分低效
# count时从头开始遍历,最坏情况n^2
# 循环避免使用count
def count_x_dict(str1):
    dic_sub = {}
    for i in str1:
        if i not in dic_sub:
            count_x = str1.count(i)
            dic_sub[i] = count_x
    return dic_sub
```

6 枚举操作中的小误解
enumerate(sequence,[,star=0])
实际并不是返回索引值。star其实是指以什么数字作为开头开始数数
如果你并不想从开头开始遍历seq，又想获取真实的引索，请看下面的例子
```python
for i in range(1, len(arr)):
  num = arr[i]

for i, num in enumerate(arr[1:], start=1):
```

7 滑动窗口题目中，提前进行赋值保存为变量的利弊
如果在循环中需要根据条件缩小窗口，连续更新l指针，此时应该使用动态的变量arr[l]
```python
for i in range(1,n):
  min_num = s_sorted[l]  # 此处提前赋值了l指针的值，好处了代码阅读起来比较容易理解
  num = s_sorted[i]
  if num - min_num <= k:
    win_num_max += 1
    if  win_num_max > max_num:
      max_num = win_num_max
  else:
    # 缩小窗口
    # 此处缩小窗口需要移动l，并进行判定，如果再用min_num 就不行了
    while l <= i and num - s_sorted[l] > k:
      l += 1
    win_num_max = i - l + 1
```


# 集合

1 集合的创建

集合的写法不要搞错了，建议统一按照下面的方法进行创建

set1 = set（obj）

集合是{}，元组是（）。不要搞错了


# 数独 DFS
易错点：
1 小九宫格的定位：(di，dj)  则左上角的坐标为x = 3 * (di//3)  y = 3 * (dy//3) 。 记乘以3
2
```python
import sys
# import os
# if __name__ == "__main__" and os.path.exists("test.txt"):
#   sys.stdin = open("test.txt", "r")

#  检查整个矩阵过于浪费时间，只要保证每个点合法，那就能保证整个矩阵合法
# 合法就是不会与其他点的值重复

def node_num_legal(node,num,M):
  di, dj = node
  # check row
  for j in range(9):
    if M[di][j] == num:
      return False
  # check col
  for i in range(9):
    if M[i][dj] == num:
      return False
  # check small Mmj
  #   注意小M的左上角是x = 3*（di//3）；y = 3*（dj//3）
  x = 3*(di//3)
  y = 3*(dj//3)
  for i in range(x, x+3):
    for j in range(y, y+3):
      if M[i][j] == num:
        return False
  return True

def DFS(node_index,graph,M):
  # 只使用引索值，更方便操作，因为这里用到越界后不存在的空节点作为结束条件
  # 终止条件：所有空填完，我们这里用空节点，或者说越界来代替
  if node_index == len(graph):
    return M

  # 处理节点和遍历节点
  # 尝试填写一个值
  di, dj = graph[node_index]
  for num in range(1,10):
    # 不要考虑细节，考虑该节点和后续整体（即子问题），他们全合法，就原问题合法
    if node_num_legal((di,dj), num , M) :
        # 注意此处与评论区题解回有点不太一样
        # 评论区的检查函数是，其他节点与该节点是否一样
        # 但此的检查函数是遍历了所有节点，但没有排除要填入的节点
        # 所以此处要先检查再填写
        # 由于上述原因，也不能将合法判断和DFS放在一起判断
      M[di][dj] = num
      result =   DFS(node_index+1,graph,M)
      if result is not None:
        return result

      M[di][dj] = 0
  # 如果到了这一步，说明已经尝试了所有值都失败了
  return None




M = [ list(map(int, line.strip().split())) for line in sys.stdin.readlines()]

zero = []
for i in range(9):
  for j in range(9):
    if M[i][j] == 0:
      zero.append((i,j))

New_M = DFS( 0,zero,M)

for i in New_M:
  print(" ".join(list(map(str, i))))


```

# 取余的计算误解
```python
lenght = 5, num = 10, k = 10
# lenght * num = 50 > 10 = k  ✓ 条件满足
# k % lenght = 10 % 5 = 0     ✗ 余数可以是0

if lenght*num > k:
    point += k//lenght * (lenght-1)
            k -=  k//lenght * lenght
            if k >1 :
                point += k-1

if lenght*num > k:
    point += k//lenght * (lenght-1) + k%length - 1

# 上面两端计算的的结果是不等价的。
# 误解在于，不要认为k%lenght 必大于0； 实际是 lenght*num % k > 0； 不要搞混了！

```
