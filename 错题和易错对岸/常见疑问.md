# 方法是否修改原对象

✅ 一、核心原则：看方法的返回值
表格
行为	返回值	是否修改原对象
原地修改（in-place）	通常返回 None	✅ 修改
返回新对象	返回新对象（如 list、str 等）	❌ 不修改
🔑 黄金法则：
如果一个方法返回 None，那它几乎一定是在原地修改对象！



# 原地修改 → 返回 None
result = lst.sort()
print(result)   # None
print(lst)      # [1, 2, 3] → 被改了！

# 返回新对象 → 不修改原对象
lst2 = [3, 1, 2]
result2 = sorted(lst2)
print(result2)  # [1, 2, 3]
print(lst2)     # [3, 1, 2] → 没变！
✅ 二、常见可变对象 vs 不可变对象
1. 可变对象（Mutable）：可以被原地修改
list, dict, set
它们的方法可能提供原地修改版本
2. 不可变对象（Immutable）：永远无法被修改
str, tuple, int, float
所有“修改”操作都必然返回新对象
💡 所以：对字符串调用任何“修改”方法，原字符串绝不会变！
python

编辑



s = "Hello"
s.upper()        # 返回 "HELLO"，但 s 还是 "Hello"
print(s)         # "Hello"

# 必须赋值才能“保存修改”
s = s.upper()
✅ 三、常见方法分类表（重点记忆）
📌 列表（list）
表格
方法	是否修改原列表	返回值	说明
list.sort()	✅ 是	None	原地排序
sorted(list)	❌ 否	新 list	返回排序后的新列表
list.append(x)	✅ 是	None	原地添加
list.extend(iter)	✅ 是	None	原地扩展
list.reverse()	✅ 是	None	原地反转
reversed(list)	❌ 否	反向迭代器	需 list(reversed(...)) 得新列表
list.copy() / list[:]	❌ 否	新 list	浅拷贝
📌 字符串（str）——所有方法都不修改原字符串！
表格
方法	是否修改原字符串	返回值
s.upper()	❌ 否	新字符串
s.replace(...)	❌ 否	新字符串
s.split()	❌ 否	新列表
s.strip()	❌ 否	新字符串
📌 字典（dict）
表格
方法	是否修改原字典	返回值
d.update(other)	✅ 是	None
d.pop(key)	✅ 是	被删除的值
d.clear()	✅ 是	None
{**d1, **d2} 或 dict(d1)	❌ 否	新字典
✅ 四、快速判断技巧（实战建议）
✅ 技巧 1：看方法名是否“命令式”
像 sort(), reverse(), append(), clear() —— 听起来像“执行一个动作”，通常是原地修改。
而 sorted(), reversed() —— 名字带 “-ed”，表示“已经完成的状态”，返回新对象。
✅ 技巧 2：在交互环境试一下
python

编辑



>>> a = [1, 3, 2]
>>> b = a.sort()
>>> print(a, b)
[1, 2, 3] None   # 看！a变了，b是None
✅ 技巧 3：不确定时，查文档或用 copy
如果怕改错，先 copy：
python

编辑



import copy
safe_list = copy.deepcopy(original)
safe_list.sort()
✅ 五、华为机试中的注意事项
输入的列表/数组通常可以安全修改（因为只是副本），所以常用 arr.sort() 节省内存。
但如果题目要求“输出原始索引”或“保持输入顺序”，就必须用 sorted() + enumerate()：
python

编辑



arr = [50, 20, 30]
indexed = sorted(enumerate(arr), key=lambda x: x[1])
# [(1, 20), (2, 30), (0, 50)] → 保留了原始下标
✅ 总结：如何区分？
表格
步骤	操作
1️⃣	看对象是否可变：str/tuple 永远不会被修改
2️⃣	看方法返回值：返回 None → 原地修改；返回新对象 → 不修改
3️⃣	记典型方法：sort, reverse, append → 原地；sorted, reversed → 新对象
4️⃣	不确定就测试 or 用 copy
💡 养成习惯：调用方法前，问自己一句：“这个操作会改变我原来的变量吗？”
掌握这一点，能避免大量隐蔽 bug！