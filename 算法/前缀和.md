# 前缀和以及其变种

## 类型
1 前缀和:快速计算区间和
2 前缀运算:结合律,可逆运算,如乘法 异或
3 二维前缀：容斥原理
4 普遍前缀：任意运算的统计，可适用于后缀
如：max(max(arr[0], arr[1]) , arr[2])


## 本质
本质上就是造了一个映射缓存结果。取结果时不用从原数组计算获取，而是在缓存结果取。这种功能有好处，但缺点也明显，当数组频繁变更的时候，不适用（线段树，可变更）。
补集思想：总数 - 不满足条件的 = 满足条件的



## 例题

### HJ121 1or0

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HJ121 1or0 - 优化版本
使用二分查找快速定位区间内的'0'段
时间复杂度：O(n + q * log(n))
"""

import sys
from bisect import bisect_left, bisect_right

def solve():
    # 读取输入
    n = int(sys.stdin.readline().strip())
    s = sys.stdin.readline().strip()
    q = int(sys.stdin.readline().strip())

    # ============================================================
    # 预处理：存储所有连续'0'段 [start, end]
    # ============================================================
    zero_segments = []  # (start, end)
    starts = []         # 单独存储start，用于二分查找

    i = 0
    # ============================================================
    # 记录连续段写法
    # ============================================================
    while i < n:
        if s[i] == '0':
            start = i # 找0并标记
            while i < n and s[i] == '0': # 在循环找1，
                i += 1
            end = i - 1
            zero_segments.append((start, end))
            starts.append(start)
        else:
            i += 1

    # ============================================================
    # 预处理：前缀和，快速计算'0'段子串数
    # prefix_sum[i] = 前i个'0'段的全'0'子串总数 （从1开始）
    # ============================================================
    prefix_sum = [0] * (len(zero_segments) + 1)
    for i, (start, end) in enumerate(zero_segments):
        seg_len = end - start + 1
        prefix_sum[i + 1] = prefix_sum[i] + seg_len * (seg_len + 1) // 2

    # ============================================================
    # 处理询问
    # ============================================================
    results = []

    for _ in range(q):
        l, r = map(int, sys.stdin.readline().strip().split())
        l, r = l - 1, r - 1  # 转0-indexed

        # 总子串数
        length = r - l + 1
        total = length * (length + 1) // 2

        # --------------------------------------------------------
        # 计算区间[l,r]内的全'0'子串数
        # 二分查找找到与[l,r]有交集的'0'段
        # --------------------------------------------------------
        zero_count = 0

        # 找到第一个start >= l 的段
        left_idx = bisect_left(starts, l)
        # 找到第一个start > r 的段
        right_idx = bisect_right(starts, r)

        # 处理左端点
        if left_idx -1 >= 0:
            eg_start, seg_end = zero_segments[left_idx - 1]
            if l <= seg_end:
                inter_start = l
                inter_end = seg_end
                inter_len = inter_end - inter_start + 1
                zero_count += inter_len * (inter_len + 1) // 2

        # 处理右端点
        if right_idx -1 >= 0:
            eg_start, seg_end = zero_segments[right_idx - 1]
            if r <= seg_end:
                inter_start = r
                inter_end = seg_end
                inter_len = inter_end - inter_start + 1
                zero_count += inter_len * (inter_len + 1) // 2

        # 遍历所有可能相交的段
        for idx in range(left_idx, right_idx):
            seg_start, seg_end = zero_segments[idx]
            # 计算交集
            inter_start = max(seg_start, l)
            inter_end = min(seg_end, r)

            if inter_start <= inter_end:
                inter_len = inter_end - inter_start + 1
                zero_count += inter_len * (inter_len + 1) // 2

        results.append(total - zero_count)

    # 输出
    for res in results:
        print(res)


if __name__ == "__main__":
    solve()

```
