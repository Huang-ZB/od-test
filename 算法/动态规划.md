# 动态规划

## 背包问题

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化

DP（动态规划）的初始化思想是‌确定递推过程的起点和边界条件‌
初始化的本质是为最简单、最基础的子问题赋予确定的值，这些值将作为后续状态转移的“种子”。

核心思想
‌识别基础情况‌：分析问题，找出那些无法再被拆分成更小子问题的“最简状态”。这些状态的值通常是已知的、固定的，或者根据问题定义直接得出。
‌赋予合理初值‌：根据问题的目标（求最大值、最小值或方案数），为这些基础状态赋予合适的初始值。
‌求最值问题‌：若目标是求‌最大值‌，通常将 dp 数组初始化为一个极小的值（如负无穷或0）；若目标是求‌最小值‌，则初始化为一个极大的值（如正无穷）。
‌求方案数问题‌：通常将 dp 或 dp 初始化为 1，表示“什么都不做”也是一种方案。
‌确保状态转移的可行性‌：初始化的值必须能支撑后续的状态转移方程。例如，在计算 dp[i] 时，它可能依赖于 dp[i-1] 或 dp[i-2]，那么 dp 和 dp‌:ml-citation{ref="1" data="citationList"} 就必须被正确初始化。
具体示例
‌斐波那契数列‌：F(n) = F(n-1) + F(n-2)。最基础的情况是 F(0) = 0 和 F(1) = 1。这两个值就是初始化的边界条件。‌
1
2
‌0/1背包问题‌：dp[i][j] 表示从前 i 个物品中选择，放入容量为 j 的背包所能获得的最大价值。当没有物品可选（i=0）或背包容量为0（j=0）时，最大价值必然为0。因此，初始化 dp[j] = 0 和 dp[i] = 0。‌
1
3
‌整数拆分‌：dp[i] 表示将整数 i 拆分成至少两个正整数的和后，这些数的最大乘积。根据定义，拆分数字0或1是没有意义的，因此通常只初始化 dp‌:ml-citation{ref="2" data="citationList"} = 1（因为2只能拆分成1+1，乘积为1），然后从 i=3 开始计算。‌
4
‌求方案数（如整数划分）‌：dp[i][j] 表示用数字1到i来恰好凑成总和j的方案数。当总和为0时，无论用哪些数字，都有一种方案——“什么都不选”，因此初始化 dp[i] = 1。‌
3

- 确定遍历顺序

1 内外层遍历问题

购物单例子：
正确做法：外层为物品遍历，内层为金额遍历

若反过来会出现什么情况：
假设 只有4个物品，主1，（主2，从1），且金额m能购买他们全部
那必定时购买全部物品，内层为物品时，对与m金额，其实实际只是从这些方案中选择（主1，主2，（主2，从1）），方案并没有包括（主1，主2，从1）的方案

2 正序倒序遍历问题
在于能否重复使用，只能出现一次，倒序。

购物单例子：
假设
只有主1、从1两件物品，即只有两个方案 (主1) 或 (主1、从1)
j = (主1+从1)+主1

dp下标
[0] -------[主1]----------[(主1+从1)]----[j]
若用正序遍历
在[主1] ~ [主1+从1] 金额之间其实只买得起主1
遍历1 ~ (主1+从1)时，dp[主1]~dp[(主1+从1)]之间，都是关于主1的状态函数，
[0] ----[主1]-------------[(主1+从1)]----[j]
             <---主1---- >

若计算再j金额时，使用方案二：
dp[j]   = max(dp[j], dp[j-(主1+从1)]+V(方案二))
        = max(dp[j], dp[主1]+V(方案二))

dp[主1]+V(方案二) 则包含了两个主1的价值，发生了重复

- 举例推导dp数组
- 初始化

## 多重背包问题

1 使用set的数据结构
无重复的要求，不要求有序
请使用set()，set 是一种基于哈希表实现的数据结构，其 add（插入）和 in（查找）操作的平均时间复杂度都是 O(1)

## 最长严格单调递增子序列

最优时间时间复杂度

利用贪心算法+二分法

[最长递增子序列（nlogn 二分法、DAG 模型 和 延伸问题） | 春水煎茶](https://hit9.dev/post/longest-increasing-subsequence-revisited)

```python
def bisnary_search(arr,target):
    # 假设区间为左闭右开 [ l , r )
    l = 0
    r = len(arr)
    # 为保证区间内整数不为空，l<r
    while l < r:
        m = l + (r-l)//2   #虽然pyhton不会int溢出，但是为了规范，要写
        if target <= arr[m]:
            r = m            # 因为右边是开区间，所以可以取m
        elif arr[m] < target:
            l = m+1            # 因为左边是闭区间
    # 循环结束的条件 l=r，此时arr[m] < target < arr[l]
    # 返回第一个大于等于target的位置,使用l、r都可以，但语义为target的值在左侧
    # target <= arr[ r , len )
    return l


def inc_max(list_h):
    # 初始化，最小递增子序列长度为1
    dp = [ 1 for i in range(len(list_h))]
    # 贪心算法数组 ，末尾元素是最长子序列的末尾元素，长度为该序列的长度
    # 初始化，加入序列的第一个元素*
    rec = [list_h[0]]
    for i in range(1,len(list_h)):
        if list_h[i] > rec[-1]:
            rec.append(list_h[i])
            dp[i] = len(rec)
        else:
            pos = bisnary_search(rec, list_h[i])
            dp[i] = pos + 1
            rec[pos] = list_h[i]
    return dp
```

## 兔子问题

实际上是一个斐波那契数列

有一种兔子，从出生后第三个月起，每个月都会生一只兔子，生出来的兔子同理。假设兔子都不死，求解第 n 个月时的兔子总数。

```python
import sys
n = int(input())
dp = [1]*(n+1)
dp[3] = 2
for i in range(4,n+1):
    dp[i] =  dp[i-1] +dp[i-2]
print(dp[n])
'''
可以这样理解递推式
f(n-1) 中分为两组：新生的 和 非新生的。而非新生的就是等于f(n-2)中的数量
所以 f(n) = 非新生的 + 新生的（由f(n-1)的非
非新生的（由f(n-1)的非新生 + 新生的变老而来）
新生的（由f(n-1)的非新生的生产而来）
'''

# 另一种思路
'''
a表示出生不低于两个月的兔子数量，b表示出生一个月的兔子数量，c表示刚出生的兔子数量，可知：每过一个月就有：
a = a + b
b = c
c = a
'''
n = int(input())
a = 1    # 出生不短于两个月的兔子
b = 0    # 出生一个月的兔子
c = 0    # 刚出生的兔子
for i in range(3, n+1):
    a += b
    b = c
    c = a

print(a+b+c)
```

## 最大公共子串

1 使用二维dp矩阵，i，j分别映射字符串的一位
状态转移方程：
s1[i] == s2[j] ; dp[i][j] = dp[i-1][j-1]+1
else: dp[i][j] = 0
意义：如果字符相同，则根据他们前一位的字符的判定情况加1

## 最长公共子序列

1 使用二维dp矩阵，i，j分别映射字符串的前i,j位的子串公共子序列
状态转移方程：
s1[i-1] == s2[j-1] ; dp[i][j] = dp[i-1][j-1]+1
else: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
意义：如果字符相同，则查看他们之前的子串的公共子序列，并加1
如果不相同，则等于取之前计算好的子串的最大值

```python
# ============================================================
# 动态规划求最长公共子序列 (LCS)
# 细节处理：
# 使用 (n+1) x (m+1) 的表格，避免边界判断；应用后一位记录前一位长度。
# dp[i][j] 表示 s[:i] 和 t[:j] 的 LCS 长度
# ============================================================
dp = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(1, m + 1):
        if s[i-1] == t[j-1]:
            # 字符相同：左上角的值 + 1
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            # 字符不同：取上方或左方的最大值
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

## 最长回文串

1 二维dp矩阵 dp[i][j]表示i~j是否是回文窜
    s[i] = s[j] ; dp[i][j]

```python
import sys
s = input()
n = len(s)
dp = [[0 for i in range(n)] for j in range(n)]
re = 1
# 初始化：考虑长度为1和2的长度
for i in range(n):
    dp[i][i] = 1
for i in range(n-1):
    if s[i] == s[i+1]:
        dp[i][i+1] = 1
        re = 2         # 不要忘记判断长度为2的是否存在   

# 遍历
# 应该按字符串的长度递增进行遍历，而不是简单的两个嵌套循环进行遍历
for i in range(3,n+1):
    start = 0
    while start + i -1 < n:
        if s[start] == s[start + i -1]:
            flag = dp[start][start + i -1] = dp[start+1][start + i -1-1] 
            if flag == 1:
                re = max(re,i)
        start += 1 

print(re)
```

## 分苹果

问题：把m个相同苹果分给n个盘子，盘子可空。（注意苹果必须分完）

思路：把问题缩减为更小的问题（分i个苹果，j个盘子）

初始化：分0,1个苹果； 分一个盘子

推导：

1 苹果不够分的情况

2 苹果够分的情况： 要不要有空盘子的情况

```python
import sys

m,n = list(map(int,input().split())) ]
# dp[i][j] 代表把i个苹果放入j个盘子中，注意不允许苹果不放的情况
dp = [[0] * (n+1) for i in range(m+1
# 初始化
# 0个或1个苹果放入j个盘子中
for i in range(1,n+1):
    dp[0][i] = 1
    dp[1][i] = 1
# i个苹果放入1个盘子中
for i in range(m+1):
    dp[i][1] = 1

# 注意已经初始化只有0、1个苹果的情况，所以应该从2开始.盘子也是同样的情况
for i in range(2,m+1):
    for j in range(2,n+1):
        # 苹果数小于盘子数，意味着必有空盘子。方案数则与少一个盘子的情况相同
        if i < j:
            dp[i][j] = dp[i][j-1]
        # 苹果数大于盘子数
        elif i>=j:
            # 1 若有空盘子的情况，则与少一个盘子的情况
            # 2 若无空盘子的情况,则意味着每个盘子必有一个苹果,
            # 若每个盘子减少一个苹果,方案数不变
            dp[i][j] = dp[i][j-1] + dp[i-j][j] 

print(dp[m][n])
```

## 气球染色（按照排列状态数构建DP）

易错点：

1 压缩空间后更新的位置有先后顺序：三颜色有依赖上一次的两颜色，两颜色依赖上一次的单颜色；所以三颜色先更新

```python
import sys

n = int(input())
s = input()
t = list(map(int,input().split()))

# dp下标前i个气球的颜色排列状态
# 0,1,2,01,02,10,12,20,21,012，021,102,120,210,201
dp = [float("inf")] * 15

# 初始化 没有气球需要染色
for i in range(3):
    dp[i] = 0

for i in range(1,n+1):
    # 第i个气球，对应s[i-1]位置
    color ,time = int(s[i-1]),t[i-1]
    # 染色对应的时间
    cost = [time] * 3
    cost[color] = 0
      
    # 三种颜色
    if i >= 3:
        dp[9] = min(dp[3],dp[9]) + cost[2]  # 012
        dp[10] = min(dp[4],dp[10]) + cost[1]  # 021
        dp[11] = min(dp[5],dp[11]) + cost[2]  # 102
        dp[12] = min(dp[6],dp[12]) + cost[0]  # 120
        dp[13] = min(dp[8],dp[13]) + cost[0]  # 210
        dp[14] = min(dp[7],dp[14]) + cost[1]  # 201

    # 有两种颜色
    if i >= 2: # 两种颜色必须两气球以上
        dp[3] = min(dp[0],dp[3]) + cost[1]  # 01
        dp[4] = min(dp[0],dp[4]) + cost[2]  # 02
        dp[5] = min(dp[1],dp[5]) + cost[0]  # 10
        dp[6] = min(dp[1],dp[6]) + cost[2]  # 12
        dp[7] = min(dp[2],dp[7]) + cost[0]  # 20
        dp[8] = min(dp[2],dp[8]) + cost[1]  # 21
      # 前面i个气球只有一种颜色
    dp[0] = dp[0] + cost[0]
    dp[1] = dp[1] + cost[1]
    dp[2] = dp[2] + cost[2]
print(min(dp))

```
