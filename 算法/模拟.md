# 四则运算
```python
import sys
def f(a,b,method):
    if method == "+":
        return a+b
    if method == "-":
        return a-b
    if method == "*":
        return a*b
    if method == "/":
        return a/b

s = input()
s = s.replace("{","(").replace("[","(").replace("}",")").replace("]",")")
stack_num = []
stack_method = []
priority ={"(":0,")":0,"+":1,"-":1,"*":2,"/":2}

# 在符号栈中分三种情况，栈顶是（   +-  /*
# 根据当前符号与栈顶符号对比
# 优先级 当前符号 <= 栈顶符号，则让栈顶进行一次计算后再压入
# 这样就能保证栈顶的符号优先级永远是最大的
i = 0
while i < len(s):  
    # 处理负数
    if s[i] == '-':
        # 第一位就是-,或者左边也是符号,则他是负号
        if i == 0 or s[i-1] in '(+-*/':
            # 记录-号，移到下一位
            num = '-'
            i += 1 
            # 每个i，都要判断是否越界
            while i < len(s) and s[i].isdigit():
                num = num + s[i]
                i += 1
            stack_num.append(int(num))
            # i跳出循环时，指向符号
            continue
    # 处理非负数字
    if s[i].isdigit():
        num = ''
        # 每个i，都要判断是否越界
        while i < len(s) and s[i].isdigit():
            num = num + s[i]
            i += 1
        stack_num.append(int(num))
        # 添加Continue节省时间
        continue
    # 处理符号
    else:
        # 首位不可能是符号，负号前面已经处理过了
        if s[i] in "+-*/":
            # 如果栈顶的优先级大于当前的符号，先计算栈顶的符号
            # 要考虑栈为空的情况
            # 注意这里要使用while，要保证前面的优先级小于当前的优先级，否则导致错误：如 4-2-3，会导致有相邻的两个相同优先级为1的运算符，由于栈的特性，会导致先算了后面，实际会得到4-(2-3)的结果
            while (stack_method and stack_method[-1] != '(' and priority[s[i]] <= priority[stack_method[-1]]):
                b = stack_num.pop()
                a = stack_num.pop()
                result = f(a,b,stack_method.pop())
                stack_num.append(result)
            stack_method.append(s[i])
               
        if s[i] == "(":
            stack_method.append(s[i])
        if s[i] == ")":
            # 因为后面又弹出操作，要考虑栈为空的情况
            while stack_method and stack_method[-1] != '(':
                b = stack_num.pop()
                a = stack_num.pop()
                result = f(a,b,stack_method.pop())
                stack_num.append(result)
            if stack_method:
                # 弹出左括号，为防止错误，最好弹出操作都要判断是否为空  
                stack_method.pop()  
        # 记得+1
        i += 1

while stack_method:
    b = stack_num.pop()
    a = stack_num.pop()
    result = f(a,b,stack_method.pop())
    stack_num.append(result)

print(int(stack_num.pop()))
```