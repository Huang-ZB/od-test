# 动态规划

## 背包问题

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化

DP（动态规划）的初始化思想是‌确定递推过程的起点和边界条件‌
初始化的本质是为最简单、最基础的子问题赋予确定的值，这些值将作为后续状态转移的“种子”。

核心思想
‌识别基础情况‌：分析问题，找出那些无法再被拆分成更小子问题的“最简状态”。这些状态的值通常是已知的、固定的，或者根据问题定义直接得出。
‌赋予合理初值‌：根据问题的目标（求最大值、最小值或方案数），为这些基础状态赋予合适的初始值。
‌求最值问题‌：若目标是求‌最大值‌，通常将 dp 数组初始化为一个极小的值（如负无穷或0）；若目标是求‌最小值‌，则初始化为一个极大的值（如正无穷）。
‌求方案数问题‌：通常将 dp 或 dp 初始化为 1，表示“什么都不做”也是一种方案。
‌确保状态转移的可行性‌：初始化的值必须能支撑后续的状态转移方程。例如，在计算 dp[i] 时，它可能依赖于 dp[i-1] 或 dp[i-2]，那么 dp 和 dp‌:ml-citation{ref="1" data="citationList"} 就必须被正确初始化。
具体示例
‌斐波那契数列‌：F(n) = F(n-1) + F(n-2)。最基础的情况是 F(0) = 0 和 F(1) = 1。这两个值就是初始化的边界条件。‌
1
2
‌0/1背包问题‌：dp[i][j] 表示从前 i 个物品中选择，放入容量为 j 的背包所能获得的最大价值。当没有物品可选（i=0）或背包容量为0（j=0）时，最大价值必然为0。因此，初始化 dp[j] = 0 和 dp[i] = 0。‌
1
3
‌整数拆分‌：dp[i] 表示将整数 i 拆分成至少两个正整数的和后，这些数的最大乘积。根据定义，拆分数字0或1是没有意义的，因此通常只初始化 dp‌:ml-citation{ref="2" data="citationList"} = 1（因为2只能拆分成1+1，乘积为1），然后从 i=3 开始计算。‌
4
‌求方案数（如整数划分）‌：dp[i][j] 表示用数字1到i来恰好凑成总和j的方案数。当总和为0时，无论用哪些数字，都有一种方案——“什么都不选”，因此初始化 dp[i] = 1。‌
3

- 确定遍历顺序

1 内外层遍历问题

购物单例子：
正确做法：外层为物品遍历，内层为金额遍历

若反过来会出现什么情况：
假设 只有4个物品，主1，（主2，从1），且金额m能购买他们全部
那必定时购买全部物品，内层为物品时，对与m金额，其实实际只是从这些方案中选择（主1，主2，（主2，从1）），方案并没有包括（主1，主2，从1）的方案

2 正序倒序遍历问题
在于能否重复使用，只能出现一次，倒序。

购物单例子：
假设 
只有主1、从1两件物品，即只有两个方案 (主1) 或 (主1、从1)
j = (主1+从1)+主1

dp下标
[0] -------[主1]----------[(主1+从1)]----[j]
若用正序遍历
在[主1] ~ [主1+从1] 金额之间其实只买得起主1
遍历1 ~ (主1+从1)时，dp[主1]~dp[(主1+从1)]之间，都是关于主1的状态函数，
[0] ----[主1]-------------[(主1+从1)]----[j]
             <---主1---- >

若计算再j金额时，使用方案二：
dp[j]   = max(dp[j], dp[j-(主1+从1)]+V(方案二))
        = max(dp[j], dp[主1]+V(方案二))

dp[主1]+V(方案二) 则包含了两个主1的价值，发生了重复

- 举例推导dp数组
- 初始化

## 多重背包问题

1 使用set的数据结构 
无重复的要求，不要求有序
请使用set()，set 是一种基于哈希表实现的数据结构，其 add（插入）和 in（查找）操作的平均时间复杂度都是 O(1)

## 最长严格单调递增子序列

最优时间时间复杂度

利用贪心算法+二分法

[最长递增子序列（nlogn 二分法、DAG 模型 和 延伸问题） | 春水煎茶](https://hit9.dev/post/longest-increasing-subsequence-revisited)

```python
def bisnary_search(arr,target):
    # 假设区间为左闭右开 [ l , r )
    l = 0
    r = len(arr)
    # 为保证区间内整数不为空，l<r
    while l < r:
        m = l + (r-l)//2   #虽然pyhton不会int溢出，但是为了规范，要写
        if target <= arr[m]:
            r = m            # 因为右边是开区间，所以可以取m
        elif arr[m] < target:
            l = m+1            # 因为左边是闭区间
    # 循环结束的条件 l=r，此时arr[m] < target < arr[l]
    # 返回第一个大于等于target的位置,使用l、r都可以，但语义为target的值在左侧 
    # target <= arr[ r , len )
    return l  


def inc_max(list_h):
    # 初始化，最小递增子序列长度为1
    dp = [ 1 for i in range(len(list_h))]
    # 贪心算法数组 ，末尾元素是最长子序列的末尾元素，长度为该序列的长度
    # 初始化，加入序列的第一个元素*
    rec = [list_h[0]]
    for i in range(1,len(list_h)):
        if list_h[i] > rec[-1]:
            rec.append(list_h[i])
            dp[i] = len(rec)
        else:
            pos = bisnary_search(rec, list_h[i])
            dp[i] = pos + 1
            rec[pos] = list_h[i]
    return dp
```

## 兔子问题

实际上是一个斐波那契数列

有一种兔子，从出生后第三个月起，每个月都会生一只兔子，生出来的兔子同理。假设兔子都不死，求解第 n 个月时的兔子总数。

```python
import sys
n = int(input())
dp = [1]*(n+1)
dp[3] = 2
for i in range(4,n+1):
    dp[i] =  dp[i-1] +dp[i-2]
print(dp[n])
'''
可以这样理解递推式 
f(n-1) 中分为两组：新生的 和 非新生的。而非新生的就是等于f(n-2)中的数量
所以 f(n) = 非新生的 + 新生的（由f(n-1)的非
非新生的（由f(n-1)的非新生 + 新生的变老而来）
新生的（由f(n-1)的非新生的生产而来）
'''

# 另一种思路
'''
a表示出生不低于两个月的兔子数量，b表示出生一个月的兔子数量，c表示刚出生的兔子数量，可知：每过一个月就有：
a = a + b
b = c
c = a
'''
n = int(input())
a = 1    # 出生不短于两个月的兔子
b = 0    # 出生一个月的兔子
c = 0    # 刚出生的兔子
for i in range(3, n+1):
    a += b
    b = c    
    c = a

print(a+b+c)
```
