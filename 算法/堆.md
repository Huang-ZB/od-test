# 堆

## 应用场景
堆（Heap）是一种高效维护动态极值的数据结构，核心优势在于：
1 插入和取出最值的时间复杂度均为 O(log n)，
2 查看最值为 O(1)。
因此，堆广泛应用于需要频繁访问或更新最大/最小元素的场景：
- TOP-K

## 性质：
1 完全二叉树 （最下层的叶都集中再左边，不能有空节点）

2 **引索关系**：
假设：
完全二叉树（Complete Binary Tree）为深度为k、有n个结点的二叉树
(另外，满二叉树的结点数为：n = 2^k -1)
- k = (log2 n)向下取整 + 1;

- 设根结点的引索为0：
- 父结点：(i-1)//2
- 左孩子：2i + 1
- 右孩子：2i + 2


## 常用操作
```python
import heapq
heap = []
heapq.heappush(heap, x)        # 插入
x = heapq.heappop(heap)        # 弹出最小值
x = heapq.heappushpop(heap, item) # 将 item 推入堆中，然后弹出并返回堆中的最小元素。这比单独调用 heappush() 和 heappop() 更高效，具体原理：先与根节点比较，后插入到尾部，根尾交换，堆化，弹出，实际只进行了一次堆化操作。
x = heap[0]                    # 查看最小值（不弹出
heapq.heapify(arr)             # 将 list 转为堆（O(n)）

heapq.nlargest(n, iterable, key=None)
返回可迭代对象中最大的 n 个元素。

heapq.nsmallest(n, iterable, key=None)
返回可迭代对象中最小的 n 个元素。
```

### 实现原理讲解

插入：插入到最后面，与父节点比较和交换，直至父节点为空或满足堆的条件
弹出：交换根节点和末尾结点，堆根结点进行调整即可，最后弹出尾节点
返回可迭代对象中最大的 n 个元素：取数组中的前n个元素并堆化（最小堆），遍历其他元素，若大于根节点，进行插入弹出操作。
