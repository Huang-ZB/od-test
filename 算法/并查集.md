# 并查集（Disjoint Set Union，DSU，不相交集合合并）

# 错题本
1 合并时，不要忘记判断根节点是否一样（即是否在同一个集合）后再进行后续合并或其他操作

# 并查集对连通分量的应用

## 思路
边 + 两节点符合条件 -> 合并操作 -> 一个并查集 = 树 = 连通分量

```python
import sys

class DSU:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.size = [1] * (n + 1)

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        # 注意要先判断是否再同意集合
        if px == py:
            return
        # 启发式合并
        if self.size[px] < self.size[py]:
            px, py = py, px
        self.parent[py] = px
        self.size[px] += self.size[py]

    def get_count(self, n):
        """计算当前并查集中所有连通分量的路径总数"""
        total = 0
        for i in range(1, n + 1):
            if self.parent[i] == i:  # 只统计根节点
                s = self.size[i]
                total += s * (s - 1) // 2
        return total


def count_paths(n, edges, weights, condition):
    """
    统计满足condition条件的节点构成的连通分量内的路径数
    condition: 判断节点是否应该被保留的函数
    """
    dsu = DSU(n)
    active = [False] * (n + 1)

    # 标记满足条件的节点
    for i in range(1, n + 1):
        if condition(weights[i]):
            active[i] = True

    # 只连接两个端点都满足条件的边
    for u, v in edges:
        if active[u] and active[v]:
            dsu.union(u, v)

    return dsu.get_count(n)


def solve():
    input_data = sys.stdin.read().split()
    idx = 0

    n = int(input_data[idx]); idx += 1
    a = int(input_data[idx]); idx += 1
    b = int(input_data[idx]); idx += 1

    weights = [0] + [int(input_data[idx + i]) for i in range(n)]
    idx += n

    edges = []
    for _ in range(n - 1):
        u = int(input_data[idx]); idx += 1
        v = int(input_data[idx]); idx += 1
        edges.append((u, v))

    # 总路径数（树中任意两点间只有一条路径）
    total_paths = n * (n - 1) // 2

    # 全>a的路径数（最小值>a，不满足条件）
    cnt_all_gt_a = count_paths(n, edges, weights, lambda w: w > a)

    # 全<b的路径数（最大值<b，不满足条件）
    cnt_all_lt_b = count_paths(n, edges, weights, lambda w: w < b)

    # 全在(a,b)内的路径数（被重复减去，需要加回）
    cnt_in_range = count_paths(n, edges, weights, lambda w: a < w < b)

    # 容斥原理
    good_paths = total_paths - cnt_all_gt_a - cnt_all_lt_b + cnt_in_range

    print(good_paths)


if __name__ == "__main__":
    solve()
```


## 二进制数按位分组

## 问题理解
给定 n 个整数，对于每个二进制位，收集所有在该位为 1 的数的**索引**。
（可推广至其他进制或一般情况）

## Python 实现

```python
def group_indices_by_bit(nums, max_bits=32):
    """
    对每个二进制位，将该位为1的所有数的索引保存到list中

    Args:
        nums: 整数列表
        max_bits: 考虑的二进制位数（默认32位）

    Returns:
        dict: key为位数，value为该位为1的索引列表
    """
    bit_indices = {i: [] for i in range(max_bits)}

    for idx, num in enumerate(nums):
        for bit in range(max_bits):
            if (num >> bit) & 1:  # 检查第bit位是否为1
                bit_indices[bit].append(idx)

    # 过滤掉空的位
    return {bit: indices for bit, indices in bit_indices.items() if indices}


# 示例使用
nums = [5, 3, 6]  # 二进制：101, 011, 110
result = group_indices_by_bit(nums, max_bits=4)

for bit, indices in sorted(result.items()):
    print(f"第{bit}位为1的索引: {indices}")
```

## 输出结果
```
第0位为1的索引: [0, 1]
第1位为1的索引: [1, 2]
第2位为1的索引: [0, 2]
```

## 解释
| 索引 | 数值 | 二进制 |
|------|------|--------|
| 0 | 5 | 101 |
| 1 | 3 | 011 |
| 2 | 6 | 110 |

- **第0位**：5(101)和3(011)的第0位是1 → 索引 `[0, 1]`
- **第1位**：3(011)和6(110)的第1位是1 → 索引 `[1, 2]`
- **第2位**：5(101)和6(110)的第2位是1 → 索引 `[0, 2]`

## 优化版本（只遍历有效位）

```python
def group_indices_by_bit_optimized(nums):
    """只遍历每个数的有效二进制位"""
    bit_indices = {}

    for idx, num in enumerate(nums):
        bit = 0
        temp = num
        while temp > 0:
            if temp & 1:
                if bit not in bit_indices:
                    bit_indices[bit] = []
                bit_indices[bit].append(idx)
            temp >>= 1
            bit += 1

    return bit_indices
```

## 时间复杂度
- **基础版本**：O(n × max_bits)
- **优化版本**：O(n × log(max_num))

需要我帮你改成其他语言（如 C++/Java）或添加其他功能吗？
