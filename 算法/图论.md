# 图论

https://blog.csdn.net/Mr_GYF/article/details/121843219


# 无向图

## 连通性
连通图： 无向图中，任意两个节点可以相互到达
连通分量：每个极大流通子图可以作为一个连通分量

## 性质
### 无向图含有n个顶点，图的边数
n-1(树) <=  边数  <=  (n-1)(n-2)//2 +1 (n-1个顶点的完全无向图 连接1个顶点组成的图)
### 总路径数
（树中任意两点间只有一条路径，即不存在环且两个节点之间最多一条边）
total_paths = n * (n - 1) // 2


# 有向图

## 连通性
强连通图：有向图中，任意两个节点可以相互到达（环）
强连通分量：每个极大强流通子图可以作为一个强连通分量

# 二分图

描述：

二分图：如果一张图可以被染为两种不同的颜色，并且一条边两端的节点颜色不同

匹配：

在一个图中，一个节点可以存在多条边（代表多种匹配的方案）

匹配边：表示两点联通

非匹配边：表示存在该联通的方案，但此时并未匹配

例子：乘客和座位可以理解为不同的节点，为一个乘客分配一个座位称为一个匹配

交替路：一条路径上非匹配边和匹配边交替出现

增广路：查找一条交替路，若反转其匹配关系，可使其匹配数加1，（实际是以非匹配边开始，也以非匹配边结束的交替路）

## 二分图的最大匹配

思路，遍历一组的节点，对每个节点使用dfs查找增广路。

### 素数伴侣

```python
import sys

def is_prime(num):
    if num == 2:
        return True
    elif num % 2 == 0:
        return False
    else:
        i = 3
        # 应该用<=
        while i*i <= num:
            if num % i ==0:
                return False
            # 别忘记+1
            i += 1
        return True

def DFS(node,visited,graph,match_odd):
    for even_index in graph.get(node,[]):
        # 不需要判断，若列表为[],就不会进入循环
        # if even_index:
        #     return False # 无法构建匹配边

        if visited[even_index] == False: # 未被访问
            visited[even_index] = True
            # if match_odd[even_index] == -1: # 邻未匹配
            #     match_odd[even_index] =  node
            #     return True # 能构建匹配边
            # else:
            #     # 如果(邻-odd),匹配边的odd节点能找到另外的even进行配对，则让当前的odd与邻匹配
            #     if DFS(match_odd[even_index],visited,graph,match_odd):
            #         match_odd[even_index] =  node
            #         return True
            # else:
            #     return False
            # for 里面只是找判断了一个even，应该遍历完全部后才return false
            # 上面可以合并，看return True是前的做法是一致的，则可以合并为一个判断
            if match_odd[even_index] == -1 or DFS(match_odd[even_index],visited,graph,match_odd):
                # even 未匹配 或 已匹配的odd'可以找到新even'
                match_odd[even_index] =  node
                return True
    return False


n = int(input())
l = list(map(int,input().split()))

odd = []
even = []

for i in l:
    if i % 2 == 0 :
        even.append(i)
    else:
        odd.append(i)
# { odd:[even_index1, even_index2, even_index3 ]   }
graph = {}
# 元素存在重复的可能，最好用引索值来代替元素，这样就不会重复了
for i, num1 in enumerate(odd):
    for j, num2  in enumerate(even):
        if is_prime(num1 + num2):
            if i not in graph:
                graph[i] = [j]
            else:
                graph[i].append(j)

# 标记数组表示even已与某odd进行匹配，match_odd[j]=i
# j->even_index ; i -> odd_index
match_odd = [-1]*len(even)
# 为每一个奇数匹配 匹配成功则+1
# 在匹配的过程会不会出现，odd已经匹配的情况
# 不会，在每次匹配过程中，增广路可能涉及的节点，最多只
# 包含所有even和之前已经遍历过的odd，
max = 0
for i, odd_num in enumerate(odd):
    # visited 标记该次dfs的even节点是否被访问过
    visited = [False] * len(even)
    if DFS(i,visited,graph,match_odd):
        max += 1

print(max)
```
