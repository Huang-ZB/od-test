# 动态规划之背包问题

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化

DP（动态规划）的初始化思想是‌确定递推过程的起点和边界条件‌
初始化的本质是为最简单、最基础的子问题赋予确定的值，这些值将作为后续状态转移的“种子”。

核心思想
‌识别基础情况‌：分析问题，找出那些无法再被拆分成更小子问题的“最简状态”。这些状态的值通常是已知的、固定的，或者根据问题定义直接得出。
‌赋予合理初值‌：根据问题的目标（求最大值、最小值或方案数），为这些基础状态赋予合适的初始值。
‌求最值问题‌：若目标是求‌最大值‌，通常将 dp 数组初始化为一个极小的值（如负无穷或0）；若目标是求‌最小值‌，则初始化为一个极大的值（如正无穷）。
‌求方案数问题‌：通常将 dp 或 dp 初始化为 1，表示“什么都不做”也是一种方案。
‌确保状态转移的可行性‌：初始化的值必须能支撑后续的状态转移方程。例如，在计算 dp[i] 时，它可能依赖于 dp[i-1] 或 dp[i-2]，那么 dp 和 dp‌:ml-citation{ref="1" data="citationList"} 就必须被正确初始化。
具体示例
‌斐波那契数列‌：F(n) = F(n-1) + F(n-2)。最基础的情况是 F(0) = 0 和 F(1) = 1。这两个值就是初始化的边界条件。‌
1
2
‌0/1背包问题‌：dp[i][j] 表示从前 i 个物品中选择，放入容量为 j 的背包所能获得的最大价值。当没有物品可选（i=0）或背包容量为0（j=0）时，最大价值必然为0。因此，初始化 dp[j] = 0 和 dp[i] = 0。‌
1
3
‌整数拆分‌：dp[i] 表示将整数 i 拆分成至少两个正整数的和后，这些数的最大乘积。根据定义，拆分数字0或1是没有意义的，因此通常只初始化 dp‌:ml-citation{ref="2" data="citationList"} = 1（因为2只能拆分成1+1，乘积为1），然后从 i=3 开始计算。‌
4
‌求方案数（如整数划分）‌：dp[i][j] 表示用数字1到i来恰好凑成总和j的方案数。当总和为0时，无论用哪些数字，都有一种方案——“什么都不选”，因此初始化 dp[i] = 1。‌
3

- 确定遍历顺序

1 内外层遍历问题

购物单例子：
正确做法：外层为物品遍历，内层为金额遍历

若反过来会出现什么情况：
假设 只有4个物品，主1，（主2，从1），且金额m能购买他们全部
那必定时购买全部物品，内层为物品时，对与m金额，其实实际只是从这些方案中选择（主1，主2，（主2，从1）），方案并没有包括（主1，主2，从1）的方案

2 正序倒序遍历问题
在于能否重复使用，只能出现一次，倒序。

购物单例子：
假设 
只有主1、从1两件物品，即只有两个方案 (主1) 或 (主1、从1)
j = (主1+从1)+主1

dp下标
[0] -------[主1]----------[(主1+从1)]----[j]
若用正序遍历
在[主1] ~ [主1+从1] 金额之间其实只买得起主1
遍历1 ~ (主1+从1)时，dp[主1]~dp[(主1+从1)]之间，都是关于主1的状态函数，
[0] ----[主1]-------------[(主1+从1)]----[j]
             <---主1---- >

若计算再j金额时，使用方案二：
dp[j]   = max(dp[j], dp[j-(主1+从1)]+V(方案二))
        = max(dp[j], dp[主1]+V(方案二))

dp[主1]+V(方案二) 则包含了两个主1的价值，发生了重复

- 举例推导dp数组
- 初始化
