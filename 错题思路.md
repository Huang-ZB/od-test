- HJ4字符串分隔

判断字符长度，分是否为0，大于8，小于8，通过列表的切片，前者进行输出和后者赋值进入下个循环

- 进制转换
  
设进制为x
通过n % x 取模的方法，依次获取低位到高位的数字

- 质因数分解

任何合数 n 的最小质因子一定 ≤ √n。
因此，我们只需枚举从 2 到 √n 的可能因子。
注意的点：
1.只有一个质因子的情况
2.枚举时应将每个数除以迭代后的数(n = n//i)直至除不尽为止，得到x个相同的因子。



- 排序注意点

1 如果是按照数字排序的话，记得要转换为int类型

2 字典排序写法

sorted(dict1) 返回的是排序号的key值列表，不能使用.items()
可用下面方法排序：
sorted_items = sorted(d.items(), key=lambda x: (-x[1], x[0]))

- 列表错误操作

1 反转操作

list1 = list(var1).reverse
错误点：
list.reverse()，reverse()是list类里面的方法，需要完整写，且返回none，导致list1 = none
所以列表转换和列表翻转应该分开进行操作
```python
list1 = list(var1)
list2 = list1.reverse
```

2 错误初始化
```python
# list1 = [] * n ,实际上这只会创建一个空列表
list1 = [] * 4                  >>> []
# 正确操作
list2 = [[] for _ in range(4)]  >>> [[], [], [], []]
list2 = [[None]] * 4            >>> [[None], [None], [None], [None]]

list2 = [None] * 4              >>> [None, None, None, None]

```

- 字符格式化操作

1.

```python
# 错误写法 {}内如果不是引索值，format()内的写法必须是 {}内变量名 = 值或者变量
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x, max_n), row)) 

# 正确写法 {}内的是参数名，format()内的是传入参数，应通过引索或者赋值的方式指示如何传入参数
formatted_row = list(map(lambda x: "{0:<{1}s}".format(x, max_n), row))
formatted_row = list(map(lambda x: "{x:<{max_n}s}".format(x=x, max_n=max_n), row))

print('{:#08x}'.format('16')) # 错误，数字格式化，不能用字符串类型
print('{:#08x}'.format(16)) 
```

- python3 除运算新特性
  
| 表达式 | 结果 | 类型 | 说明 |
|--------|------|------|------|
| `7 / 2` | `3.5` | `float` | 真除法（true division） |
| `7 // 2` | `3` | `int` | 整除（floor division） |
| `8 / 2` | `4.0` | `float` | 即使整除也是 float |
| `8 // 2` | `4` | `int` | ✅ 真正的整数 |

- 字符串操作

split()方法注意点：
'.'split(".") >>> ['', '']
是会返回空元素的，需要考虑空元素的存在

- HJ18 识别有效的IP地址和掩码并进行分类统计

注意审题
"0.*.*.*" 和 "127.*.*.*" 的 IP 地址不计入任何类别，也不计入非法统计
正确逻辑
IP是否合法
不合法 
合法：
0,127判断>不操作
错误mask判断
再进行分类

- 子字符串重复验证
  
思路：假设验证是否存在m长度以上的子串重复，只需要判断字符串中(m+1)长度是否存在重复即可
暴力：切片，与后面的比较
辅助字典查看是否重复或列表 查看去重后长度是否一致